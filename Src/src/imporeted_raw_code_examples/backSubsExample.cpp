/// initial code from : http://study.marearts.com/2014/04/opencv-study-background-subtraction-and.html

#include < stdio.h>
#include < iostream>
//
//#include < opencv2\opencv.hpp>
//#include < opencv2/core/core.hpp>
//#include < opencv2/highgui/highgui.hpp>
//#include < opencv2/video/background_segm.hpp>
//
//
//#ifdef _DEBUG        
//#pragma comment(lib, "opencv_core247d.lib")
//#pragma comment(lib, "opencv_imgproc247d.lib")   //MAT processing
//#pragma comment(lib, "opencv_objdetect247d.lib") //HOGDescriptor
////#pragma comment(lib, "opencv_gpu247d.lib")
////#pragma comment(lib, "opencv_features2d247d.lib")
//#pragma comment(lib, "opencv_highgui247d.lib")
//#pragma comment(lib, "opencv_ml247d.lib")
////#pragma comment(lib, "opencv_stitching247d.lib");
////#pragma comment(lib, "opencv_nonfree247d.lib");
//#pragma comment(lib, "opencv_video247d.lib")
//#else
//#pragma comment(lib, "opencv_core247.lib")
//#pragma comment(lib, "opencv_imgproc247.lib")
//#pragma comment(lib, "opencv_objdetect247.lib")
////#pragma comment(lib, "opencv_gpu247.lib")
////#pragma comment(lib, "opencv_features2d247.lib")
//#pragma comment(lib, "opencv_highgui247.lib")
//#pragma comment(lib, "opencv_ml247.lib")
////#pragma comment(lib, "opencv_stitching247.lib");
////#pragma comment(lib, "opencv_nonfree247.lib");
//#pragma comment(lib, "opencv_video247d.lib")
//#endif 
//

using namespace cv;
using namespace std;

//
//#include "imporeted_raw_code_examples/grabcut_from_OpencvSamples.cpp"


int mainBgndSubs()
{

 //global variables
 Mat frame; //current frame
 Mat resize_blur_Img;
 Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
 Mat binaryImg;
 Mat bgAvg;
 //Mat TestImg;
 Mat ContourImg; //fg mask fg mask generated by MOG2 method
 ///Ptr< BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
 Ptr< BackgroundSubtractorMOG2> pMOG2; //MOG2 Background subtractor 

 ///pMOG2 = new BackgroundSubtractorMOG2(300,32,true);//300,0.0);
 pMOG2			= createBackgroundSubtractorMOG2(300 ,32, true);

 ///char fileName[100] = "mm2.avi"; //video\\mm2.avi"; //mm2.avi"; //cctv 2.mov"; //mm2.avi"; //";//_p1.avi";
 ///VideoCapture stream1(fileName);   //0 is the id of video device.0 if you have only one camera   
 VideoCapture stream1(0+ 1);///0

 //morphology element
 Mat element = getStructuringElement(MORPH_RECT, Size(7, 7), Point(3,3) );   

 bool foundFirstMovingTarget = false;

 //unconditional loop   
 while (true) {   
  Mat cameraFrame;   
  if(!(stream1.read(frame))) //get one frame form video   
   break;
  
  //Resize
  resize(frame, resize_blur_Img, Size(frame.size().width/3, frame.size().height/3) );
  //Blur
  blur(resize_blur_Img, resize_blur_Img, Size(4,4) );
  //Background subtraction
  ///pMOG2->operator()(resize_blur_Img, fgMaskMOG2, -1);//,-0.5);
  pMOG2->apply(resize_blur_Img, fgMaskMOG2, -1.0);//,-0.5);
  ///////////////////////////////////////////////////////////////////
  //pre procesing
  //1 point delete
  //morphologyEx(fgMaskMOG2, fgMaskMOG2, CV_MOP_ERODE, element);
  morphologyEx(fgMaskMOG2, binaryImg, CV_MOP_CLOSE, element);
  //morphologyEx(fgMaskMOG2, testImg, CV_MOP_OPEN, element);

  //Shadow delete
  //Binary
  ///threshold(binaryImg, binaryImg, 100, 255, CV_THRESH_BINARY);  // indoor threshould 100 (127 actually) and above
  threshold(binaryImg, binaryImg, 128, 255, CV_THRESH_BINARY);  // outdoor threshould 128 and above


  //Find contour
  ContourImg = binaryImg.clone();
  //less blob delete
  vector< vector< Point> > contours;
  findContours(ContourImg,
            contours, // a vector of contours
            CV_RETR_EXTERNAL, // retrieve the external contours
            CV_CHAIN_APPROX_NONE); // all pixels of each contours

  vector< Rect > output;
  vector< vector< Point> >::iterator itc= contours.begin();
  while (itc!=contours.end()) {

   //Create bounding rect of object
   //rect draw on origin image
   Rect mr= boundingRect(Mat(*itc));
   rectangle(resize_blur_Img, mr, CV_RGB(255,0,0));
   ++itc;
  }
  
  ///////////////////////////////////////////////////////////////////

  //Display
  imshow("Shadow_Removed"	, binaryImg);
  imshow("Blur_Resize"		, resize_blur_Img);
  imshow("MOG2"				, fgMaskMOG2);
  
  pMOG2->getBackgroundImage(bgAvg);
  imshow("bgAvg", bgAvg);

  /////

  static int	frame_counter	= 0;
  int			mask_status		= 0;
  Moments		m;
  double		boundAreaRatio;
  Point			MassCenter ;
  double		rCircle;			// estimated rounding circle for the object area
  Rect			boundRect;
  int			w				= binaryImg.cols;

  m				= moments(binaryImg, false);				// points moment 
  MassCenter	= Point(m.m10/m.m00, m.m01/m.m00);	// mass_centers
  rCircle		= sqrt(m.m00/3.14)/13 ;	
  boundRect		= boundingRect ( binaryImg );
  if ( (!foundFirstMovingTarget) &&
  (2.*rCircle < w* 0.9) && (2.*rCircle > w * 0.1) &&
	  (MassCenter.x > w * 0.3 ) && (MassCenter.x < w * 0.7 )
	  )
  {
	  foundFirstMovingTarget = true;
	  imshow("foundFirstMovingTarget", frame);

	  Mat resize_blur_ImgColor = resize_blur_Img.clone();
	  cv::cvtColor(resize_blur_Img , resize_blur_Img  , CV_BGR2GRAY);

	  cv::cvtColor(bgAvg , bgAvg  , CV_BGR2GRAY);


	  Mat diffImMask =///= binaryImg ;
		///diffImMask =
		  resize_blur_Img - bgAvg ;

	  imshow("diff image msk0", diffImMask);

///	  cv::cvtColor(diffImMask , diffImMask  , CV_BGR2GRAY);

	  imshow("diff image msk1", diffImMask);
	  threshold(diffImMask, diffImMask, 52, 255, CV_THRESH_BINARY);//128


	  Mat diffIm;
	  resize_blur_ImgColor.copyTo(diffIm, diffImMask);
	  imshow("diff image", diffIm);
	 // 

	  // make segmentation? graphCut
	  //mainGC
	  //grabCut( *image, mask, rect, bgdModel, fgdModel, 1, GC_INIT_WITH_MASK );
	  //Mat bgdModel = bgAvg.clone();
	  //Mat fgdModel = diffIm.clone();
	  //grabCut( resize_blur_Img, binaryImg, boundRect, bgdModel, fgdModel, 1, GC_INIT_WITH_MASK );
	  //imshow("grabcut output",fgdModel );
  }

  /////

  if (waitKey(5) >= 0)   
   break;   
 }
 return 0;
}


